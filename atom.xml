<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lin Niu</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-30T08:08:26.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>燕云十八飞骑，奔腾如虎风烟举</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux 0.12内核中signal的实现</title>
    <link href="http://yoursite.com/2018/05/25/signal1/"/>
    <id>http://yoursite.com/2018/05/25/signal1/</id>
    <published>2018-05-24T16:00:00.000Z</published>
    <updated>2018-05-30T08:08:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-sys-signal"><a href="#1-sys-signal" class="headerlink" title="1.sys_signal"></a>1.sys_signal</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">int sys_signal(int signum, long handler, long restorer)</div><div class="line">&#123;</div><div class="line">	struct sigaction tmp;</div><div class="line">	//SIGKILL和SIGSTOP不能被进程捕获</div><div class="line">	if (signum&lt;1 || signum&gt;32 || signum==SIGKILL || signum==SIGSTOP)</div><div class="line">		return -EINVAL;</div><div class="line">	tmp.sa_handler = (void (*)(int)) handler; //设置信号处理句柄</div><div class="line">	tmp.sa_mask = 0; </div><div class="line">	//该信号处理句柄只使用一次就恢复到默认值</div><div class="line">	tmp.sa_flags = SA_ONESHOT | SA_NOMASK; </div><div class="line">	tmp.sa_restorer = (void (*)(void)) restorer;</div><div class="line">	//取该信号原来的处理句柄，安装新句柄，返回旧句柄</div><div class="line">	handler = (long) current-&gt;sigaction[signum-1].sa_handler;</div><div class="line">	current-&gt;sigaction[signum-1] = tmp;</div><div class="line">	return handler;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-sys-sigaction"><a href="#2-sys-sigaction" class="headerlink" title="2.sys_sigaction"></a>2.sys_sigaction</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">int sys_sigaction(int signum, const struct sigaction * action,</div><div class="line">	struct sigaction * oldaction)</div><div class="line">&#123;</div><div class="line">	struct sigaction tmp;</div><div class="line"></div><div class="line">	if (signum&lt;1 || signum&gt;32 || signum==SIGKILL || signum==SIGSTOP)</div><div class="line">		return -EINVAL;</div><div class="line">	//取原sigaction</div><div class="line">	tmp = current-&gt;sigaction[signum-1];</div><div class="line">	//利用参数action设置新的sigaction</div><div class="line">	get_new((char *) action,</div><div class="line">		(char *) (signum-1+current-&gt;sigaction));</div><div class="line">	//若oldaction非空，利用前面保存的tmp填装oldaction</div><div class="line">	if (oldaction)</div><div class="line">		save_old((char *) &amp;tmp,(char *) oldaction);</div><div class="line">	//如果允许信号在自己的句柄中收到，设置sa_mak为0， 否则屏蔽这个信号</div><div class="line">	if (current-&gt;sigaction[signum-1].sa_flags &amp; SA_NOMASK)</div><div class="line">		current-&gt;sigaction[signum-1].sa_mask = 0;</div><div class="line">	else</div><div class="line">		current-&gt;sigaction[signum-1].sa_mask |= (1&lt;&lt;(signum-1));</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-do-signal函数修改用户栈的过程："><a href="#3-do-signal函数修改用户栈的过程：" class="headerlink" title="3.do_signal函数修改用户栈的过程："></a>3.do_signal函数修改用户栈的过程：</h2><p><img src="http://ous5r4na6.bkt.clouddn.com/43D00015-AC14-45DD-B1C7-1B6067B59DF1.png" alt="">  </p>
<pre><code>int do_signal(long signr,long eax,long ebx, long ecx, long edx, long orig_eax,
    long fs, long es, long ds,
    long eip, long cs, long eflags,
    unsigned long * esp, long ss)
{
    unsigned long sa_handler;
    long old_eip=eip;  //eip为原本要执行的代码
    struct sigaction * sa = current-&gt;sigaction + signr - 1;
    int longs;

    unsigned long * tmp_esp;

#ifdef notdef
    printk(&quot;pid: %d, signr: %x, eax=%d, oeax = %d, int=%d\n&quot;,
        current-&gt;pid, signr, eax, orig_eax,
        sa-&gt;sa_flags &amp; SA_INTERRUPT);
#endif
    if ((orig_eax != -1) &amp;&amp;
        ((eax == -ERESTARTSYS) || (eax == -ERESTARTNOINTR))) {
        if ((eax == -ERESTARTSYS) &amp;&amp; ((sa-&gt;sa_flags &amp; SA_INTERRUPT) ||
            signr &lt; SIGCONT || signr &gt; SIGTTOU))
            *(&amp;eax) = -EINTR;
        else {
            *(&amp;eax) = orig_eax;
            *(&amp;eip) = old_eip -= 2;
        }
    }
    sa_handler = (unsigned long) sa-&gt;sa_handler;
    if (sa_handler==1)  //默认忽略句柄SIG_IGN,不作任何处理
        return(1);   /* Ignore, see if there are more signals... */
    if (!sa_handler) {
        switch (signr) {
        case SIGCONT:
        case SIGCHLD:
            return(1);  /* Ignore, ... */

        case SIGSTOP:
        case SIGTSTP:
        case SIGTTIN:
        case SIGTTOU:
            current-&gt;state = TASK_STOPPED;
            current-&gt;exit_code = signr;
            if (!(current-&gt;p_pptr-&gt;sigaction[SIGCHLD-1].sa_flags &amp;
                    SA_NOCLDSTOP))
                current-&gt;p_pptr-&gt;signal |= (1&lt;&lt;(SIGCHLD-1));
            return(1);  /* Reschedule another event */

        case SIGQUIT:
        case SIGILL:
        case SIGTRAP:
        case SIGIOT:
        case SIGFPE:
        case SIGSEGV:
            if (core_dump(signr))
                do_exit(signr|0x80);
            /* fall through */
        default:
            do_exit(signr);  //可作为wait()或wait_pid()函数的状态信息，取得进程的退出状态码或子进程终止的原因
        }
    }
    /*
     * OK, we&apos;re invoking a handler
     */
    if (sa-&gt;sa_flags &amp; SA_ONESHOT)
        sa-&gt;sa_handler = NULL; //该句柄只执行一次
    *(&amp;eip) = sa_handler; //eip指向信号处理程序
    longs = (sa-&gt;sa_flags &amp; SA_NOMASK)?7:8;
    *(&amp;esp) -= longs;
    verify_area(esp,longs*4);
    tmp_esp=esp;
    put_fs_long((long) sa-&gt;sa_restorer,tmp_esp++);
    put_fs_long(signr,tmp_esp++);
    if (!(sa-&gt;sa_flags &amp; SA_NOMASK))
        put_fs_long(current-&gt;blocked,tmp_esp++);
    put_fs_long(eax,tmp_esp++);
    put_fs_long(ecx,tmp_esp++);
    put_fs_long(edx,tmp_esp++);
    put_fs_long(eflags,tmp_esp++);
    put_fs_long(old_eip,tmp_esp++);
    current-&gt;blocked |= sa-&gt;sa_mask;
    return(0);        /* Continue, execute handler */
}
</code></pre><p>do_signal()执行完后，system_call.s将会把内核态堆栈上eip以下的所有值弹出。<br>在执行iret之后，内核态堆栈上的cs:eip，eflags, ss:esp被弹出，恢复到用户态中执行<br>而eip已经指向了信号处理程序，因此会立即执行用户自定义信号处理程序。<br>在该信号处理程序执行完后，通过ret指令，cpu把控制权交给sa_restorer所指向的恢复程序，sa_restorer会清理用户态堆栈，弹出信息，一直弹到old_eip，最后通过sa_restorer的ret弹出old_eip并跳转到其指向的代码中运行。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-sys-signal&quot;&gt;&lt;a href=&quot;#1-sys-signal&quot; class=&quot;headerlink&quot; title=&quot;1.sys_signal&quot;&gt;&lt;/a&gt;1.sys_signal&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;
    
    </summary>
    
      <category term="kernel 0.12" scheme="http://yoursite.com/categories/kernel-0-12/"/>
    
    
  </entry>
  
  <entry>
    <title>信号</title>
    <link href="http://yoursite.com/2018/05/20/signal/"/>
    <id>http://yoursite.com/2018/05/20/signal/</id>
    <published>2018-05-19T16:00:00.000Z</published>
    <updated>2018-05-30T08:13:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>信号是一种软中断，它提供了一种异步事件处理的方法<br>信号出现时，内核的处理方式有三种：<br>1.忽略信号<br>2.捕捉信号<br>3.执行系统默认动作     </p>
<h2 id="2-函数signal"><a href="#2-函数signal" class="headerlink" title="2. 函数signal"></a>2. 函数signal</h2><blockquote>
<p>void (*signal (int signo, void ( *func )(int))) (int);<br>参数说明：signo是信号名， func为常量SIG_IGN, SIG_DFL, 或者处理该信号的函数地址</p>
</blockquote>
<p>signal函数实例:     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">int main(void) &#123;</div><div class="line">	if (signal(SIGUSR1, sig_usr) == SIG_ERR)</div><div class="line">		err_sys(&quot;can&apos;t catch SIGUSR1&quot;);</div><div class="line">	if (signal(SIGUSR2, sig_usr) == SIG_ERR)</div><div class="line">		err_sys(&quot;can&apos;t catch SIGUSR1&quot;);</div><div class="line">	for ( ; ; )</div><div class="line">		pause();     </div><div class="line">&#125;</div><div class="line">static void sig_usr(int signo) &#123;</div><div class="line">	if (signo == SIGUSR1)</div><div class="line">		printf(&quot;received SIGUSR1\n&quot;);</div><div class="line"></div><div class="line">	else if (signo == SIGUSR2)</div><div class="line">		printf(&quot;received SIGUSR2\n&quot;);</div><div class="line">	else</div><div class="line">		err_dump(&quot;received signal %d\n&quot;, signo);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>运行结果：<br>[root@centos apue]# kill -SIGUSR1 13082<br>received SIGUSR1<br>[root@centos apue]# kill -SIGUSR2 13082<br>received SIGUSR2<br>[root@centos apue]# kill  13082<br>SIGTERM默认的处理动作为终止！   </p>
</blockquote>
<h2 id="3-函数sigaction"><a href="#3-函数sigaction" class="headerlink" title="3.函数sigaction"></a>3.函数sigaction</h2><blockquote>
<p>int sigaction(int signo, const struct sigaction *restrict act, struct sigaction *restrict oact);<br>参数说明：signo为信号编号， 若act非空，修改其动作。若oact非空，借助oact指针返回该信号的上一个动作   </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct sigaction &#123;</div><div class="line">	void (*sa_handler)(int);</div><div class="line">	sigset_t sa_mask;</div><div class="line">	int sa_flags;</div><div class="line">	void (*sa_restorer)(void);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>sa_mask是一个信号集，在调用信号捕捉函数之前，要将该信号集加到进程的信号屏蔽字中，仅当从捕捉函数返回之时再恢复进程之前的信号屏蔽字</p>
</blockquote>
<p>用sigaction实现signal函数      </p>
<pre><code>Sigfunc* signal(int signo, Sigfunc* func) {    
    struct sigaction act, oact;    
    act.sa_handler = func;    
    sigemptyset(&amp;act.sa_mask); //初始化，清除指定信号集中的所有信号,也就是响应所有信号
    act.sa_flags = 0;
    if (signo == SIGALARM) {
#ifdef SA_INTERRUPT
        act.sa_flags |= SA_INTERRUPT; //由此信号中断的系统调用不自动重启
#endif      
    } else {
        act.sa_flags |= SA_RESTART;   //由此信号中断的系统调用自动重启
    }
    if (sigaction(signo, &amp;act, &amp;ocat) &lt; 0)
        return SIG_ERR;
    return oact.sa_handler;
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/a&gt;1. 概念&lt;/h2&gt;&lt;p&gt;信号是一种软中断，它提供了一种异步事件处理的方法&lt;br&gt;信号出现时，内核的处理方式有三种：&lt;br&gt;1.忽略信号&lt;br&gt;2
    
    </summary>
    
      <category term="apue, signal" scheme="http://yoursite.com/categories/apue-signal/"/>
    
    
  </entry>
  
  <entry>
    <title>线程（1）： 线程和线程标识</title>
    <link href="http://yoursite.com/2018/04/18/pthread1/"/>
    <id>http://yoursite.com/2018/04/18/pthread1/</id>
    <published>2018-04-18T11:28:27.000Z</published>
    <updated>2018-04-18T12:04:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>一个进程中的所有线程都可以访问该进程的组成部件，包括文件描述符和内存。<br>每个线程包含有表示执行环境所需要的信息，其中包括标识信息线程ID， 一组寄存器值，栈，调度优先级和策略、信号屏蔽字， error变量以及线程私有数据。<br>一个进程的所有信息对该进程的所有线程都是共享的， 包括可执行程序代码、程序的全局内存和堆内存，栈以及文件描述符。   </p>
<h2 id="2-线程标识"><a href="#2-线程标识" class="headerlink" title="2. 线程标识"></a>2. 线程标识</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(1) 比较两个线程id</div><div class="line">int pthread_equal(pthread_t tid1, pthread_t tid2);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(2) 获得自身线程id</div><div class="line">pthread_t pthread_self(void);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/a&gt;1. 概念&lt;/h2&gt;&lt;p&gt;一个进程中的所有线程都可以访问该进程的组成部件，包括文件描述符和内存。&lt;br&gt;每个线程包含有表示执行环境所需要的信息，其
    
    </summary>
    
      <category term="apue, pthread" scheme="http://yoursite.com/categories/apue-pthread/"/>
    
    
  </entry>
  
  <entry>
    <title>避免zombie process</title>
    <link href="http://yoursite.com/2018/04/13/twofork/"/>
    <id>http://yoursite.com/2018/04/13/twofork/</id>
    <published>2018-04-13T09:21:52.000Z</published>
    <updated>2018-04-13T09:46:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-僵死进程"><a href="#1-僵死进程" class="headerlink" title="1.僵死进程"></a>1.僵死进程</h2><p>是指一个已经终止，但是其父进程尚未对其进行善后处理的进程，这个处理包括获取终止子进程的有关信息，释放它占用的资源等。</p>
<h2 id="2-两次fork避免zombie"><a href="#2-两次fork避免zombie" class="headerlink" title="2.两次fork避免zombie"></a>2.两次fork避免zombie</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">int main(void) &#123;</div><div class="line">    pid_t pid;</div><div class="line">    printf(&quot;parent id=%ld\n&quot;, (long)getpid());</div><div class="line">    if ((pid = fork()) &lt; 0)</div><div class="line">        err_sys(&quot;fork error&quot;);</div><div class="line">    else if (pid == 0) &#123;</div><div class="line">        if ((pid = fork()) &lt; 0)</div><div class="line">            err_sys(&quot;fork error&quot;);</div><div class="line">        else if (pid &gt; 0) </div><div class="line">            exit(0); //first child die</div><div class="line">        sleep(2);  </div><div class="line">        printf(&quot;second child, parent pid=%ld\n&quot;, (long)getppid());</div><div class="line">        exit(0);</div><div class="line">    &#125;</div><div class="line">    if (waitpid(pid, NULL ,0) != pid)</div><div class="line">        err_sys(&quot;waitpid error&quot;);</div><div class="line">    else</div><div class="line">        printf(&quot;first child pid=%d\n&quot;, pid);</div><div class="line">    exit(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>运行结果：<br>[root@centos apue]# ./a.out<br>parent id=3483<br>first child pid=3484<br>[root@centos apue]# second child, parent pid=1</p>
</blockquote>
<p>这里，第二个子进程最终由init进程（pid=1）收养， 那么它会变成一个僵死进程吗？<br>apue中给出的解释： 对于init，任何时候只要有一个子进程终止，它就会调用一个wait函数取得这个子进程的终止状态，这样就防止系统中塞满僵死进程。<br>一个init子进程可能是init直接产生的子进程，还有一种，就是如上，父进程终止，由init接管的子进程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-僵死进程&quot;&gt;&lt;a href=&quot;#1-僵死进程&quot; class=&quot;headerlink&quot; title=&quot;1.僵死进程&quot;&gt;&lt;/a&gt;1.僵死进程&lt;/h2&gt;&lt;p&gt;是指一个已经终止，但是其父进程尚未对其进行善后处理的进程，这个处理包括获取终止子进程的有关信息，释放它占用的
    
    </summary>
    
      <category term="apue" scheme="http://yoursite.com/categories/apue/"/>
    
    
  </entry>
  
  <entry>
    <title>冲洗内存流和追加写null字节策略</title>
    <link href="http://yoursite.com/2018/04/08/fmemopen/"/>
    <id>http://yoursite.com/2018/04/08/fmemopen/</id>
    <published>2018-04-08T11:43:42.000Z</published>
    <updated>2018-04-10T08:55:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-内存流"><a href="#1-内存流" class="headerlink" title="1.内存流"></a>1.内存流</h2><p>FILE <em>fmemopen(void </em>restrict buf, size_t size, const char *restrict type);<br>返回值： 成功返回流指针，错误返回NULL</p>
<h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2.示例"></a>2.示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">int main() &#123;</div><div class="line">    FILE *fp;</div><div class="line">    char buf[BSZ];</div><div class="line"></div><div class="line">    memset(buf, &apos;a&apos;, BSZ - 2);</div><div class="line">    buf[BSZ-2] = &apos;\0&apos;;</div><div class="line">    buf[BSZ-1] = &apos;X&apos;;</div><div class="line">    </div><div class="line">	 //&quot;w+&quot;:把文件截断至0，为读和写打开</div><div class="line">    if ((fp = fmemopen(buf, BSZ, &quot;w+&quot;)) == NULL)</div><div class="line">        err_sys(&quot;fmemopen failed\n&quot;);</div><div class="line">    //1</div><div class="line">    //2</div><div class="line">    //3</div><div class="line">    //4    </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>任何时候需要增加流缓冲中数据量以及调用fclose,fflush, fseek, fseeko以及fsetpos时会在当前位置写入一个null字节</strong><br>调用fmemopen函数在缓冲区开始放置null字符</p>
<h3 id="1-offset-0"><a href="#1-offset-0" class="headerlink" title="(1).offset=0"></a>(1).offset=0</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">printf(&quot;initial buffer contents: %s\n&quot;, buf);</div><div class="line">fprintf(fp, &quot;hello, world&quot;);  //hello, world写入</div><div class="line">printf(&quot;before flush: %s\n&quot;, buf);</div><div class="line">fflush(fp);</div><div class="line">printf(&quot;after fflush: %s\n&quot;, buf);</div><div class="line">printf(&quot;length of string in buf = %ld\n&quot;, (long)strlen(buf));</div></pre></td></tr></table></figure>
<blockquote>
<p>运行结果：<br>[root@centos apue]# ./a.out<br>initial buffer contents:<br>before flushed:<br>after fflush: hello, world<br>length of string in buf = 12    </p>
</blockquote>
<p>hello, world共12个字符，此时offset=12, 偏移12处的内容为null(上面加深部分有提：调用fflush会在当前位置写入一个null字节)</p>
<h3 id="2-offset-12"><a href="#2-offset-12" class="headerlink" title="(2).offset=12"></a>(2).offset=12</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">memset(buf, &apos;b&apos;, BSZ - 2);</div><div class="line">buf[BSZ-2] = &apos;\0&apos;;</div><div class="line">buf[BSZ-1] = &apos;X&apos;;</div><div class="line">fprintf(fp, &quot;hello, world&quot;);</div><div class="line">fseek(fp, 0, SEEK_CUR);</div><div class="line">printf(&quot;after fseek SEEK_CUR: %s\n&quot;, buf);</div><div class="line">printf(&quot;length of string in buf = %ld\n&quot;, (long)strlen(buf));</div></pre></td></tr></table></figure>
<blockquote>
<p>运行结果：<br>[root@centos apue]# ./a.out<br>initial buffer contents:<br>before flushed:<br>after fflush: hello, world<br>length of string in buf = 12<br>after fseek SEEK_CUR: bbbbbbbbbbbbhello, world<br>length of string in buf = 24</p>
</blockquote>
<p>前12个被b填充，从offset=12开始填充hello, world字符串。同时，seek设置SEEK_CUR, offset=24.</p>
<h3 id="3-offset-24"><a href="#3-offset-24" class="headerlink" title="(3).offset=24"></a>(3).offset=24</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">memset(buf, &apos;c&apos;, BSZ - 2);</div><div class="line">buf[BSZ-2] = &apos;\0&apos;;</div><div class="line">buf[BSZ-1] = &apos;X&apos;;</div><div class="line">fprintf(fp, &quot;hello, world&quot;);</div><div class="line">fseek(fp, 0, SEEK_SET);</div><div class="line">printf(&quot;after fseek SEEK_SET: %s\n&quot;, buf);</div><div class="line">printf(&quot;length of string in buf = %ld\n&quot;, (long)strlen(buf));</div></pre></td></tr></table></figure>
<blockquote>
<p>运行结果：<br>[root@centos apue]# ./a.out<br>initial buffer contents:<br>before flushed:<br>after fflush: hello, world<br>length of string in buf = 12<br>after fseek SEEK_CUR: bbbbbbbbbbbbhello, world<br>length of string in buf = 24<br>after fseek SEEK_SET: cccccccccccccccccccccccchello, world<br>length of string in buf = 36  </p>
</blockquote>
<p>seek设置SEEK_SET之后，偏移值设置为缓冲区开始位置，即offset=0  </p>
<h3 id="4-offset-0"><a href="#4-offset-0" class="headerlink" title="(4).offset=0"></a>(4).offset=0</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">memset(buf, &apos;d&apos;, BSZ - 2);</div><div class="line">   buf[BSZ-2] = &apos;\0&apos;;</div><div class="line">   buf[BSZ-1] = &apos;X&apos;;</div><div class="line">   fprintf(fp, &quot;hello, world&quot;);</div><div class="line">   </div><div class="line">   fclose(fp);</div><div class="line">   printf(&quot;after close: %s\n&quot;, buf);</div><div class="line">   printf(&quot;length of string in buf = %ld\n&quot;, (long)strlen(buf));</div></pre></td></tr></table></figure>
<blockquote>
<p>运行结果：<br>[root@centos apue]# ./a.out<br>initial buffer contents:<br>before flushed:<br>after fflush: hello, world<br>length of string in buf = 12<br>after fseek SEEK_CUR: bbbbbbbbbbbbhello, world<br>length of string in buf = 24<br>after fseek SEEK_SET: cccccccccccccccccccccccchello, world<br>length of string in buf = 36<br>after close: hello, worlddddddddddddddddddddddddddddddddddd<br>length of string in buf = 46    </p>
</blockquote>
<p>这里调用了fclose，前面提到本应追加null字节，但是这里没有，为什么呢？？？    </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-内存流&quot;&gt;&lt;a href=&quot;#1-内存流&quot; class=&quot;headerlink&quot; title=&quot;1.内存流&quot;&gt;&lt;/a&gt;1.内存流&lt;/h2&gt;&lt;p&gt;FILE &lt;em&gt;fmemopen(void &lt;/em&gt;restrict buf, size_t size, con
    
    </summary>
    
      <category term="apue" scheme="http://yoursite.com/categories/apue/"/>
    
    
      <category term="apue" scheme="http://yoursite.com/tags/apue/"/>
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>VFS虚拟文件系统</title>
    <link href="http://yoursite.com/2018/03/28/vfs/"/>
    <id>http://yoursite.com/2018/03/28/vfs/</id>
    <published>2018-03-28T11:10:24.000Z</published>
    <updated>2018-03-28T11:15:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>把表示很多不同种类文件系统的共同信息放入内核，其中有一个字段或函数来支持linux所支持的所有文件系统所提供的任何操作。对所调用的每个读、写或其它函数，内核都把它们替换成支持本地linux文件系统的实际函数，其健壮性表现在能为各种文件系统提供一个通用的接口。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1.介绍&quot;&gt;&lt;/a&gt;1.介绍&lt;/h2&gt;&lt;p&gt;把表示很多不同种类文件系统的共同信息放入内核，其中有一个字段或函数来支持linux所支持的所有文件系统所提供的任何操作。对所
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jbd源代码分析</title>
    <link href="http://yoursite.com/2018/03/22/jbd/"/>
    <id>http://yoursite.com/2018/03/22/jbd/</id>
    <published>2018-03-22T12:42:35.000Z</published>
    <updated>2018-04-08T10:28:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>1.buffer_head<br>内核用于管理磁盘缓冲区的数据结构，一个buffer_head对应一个文件系统块，即对应一个磁盘块。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;1.buffer_head&lt;br&gt;内核用于管理磁盘缓冲区的数据结构，一个buffer_head对应一个文件系统块，即对应一个
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="kernel" scheme="http://yoursite.com/tags/kernel/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="jbd" scheme="http://yoursite.com/tags/jbd/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务的提交</title>
    <link href="http://yoursite.com/2018/03/19/committransaction/"/>
    <id>http://yoursite.com/2018/03/19/committransaction/</id>
    <published>2018-03-19T09:31:48.000Z</published>
    <updated>2018-04-08T10:26:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-分布式事务的提交"><a href="#1-分布式事务的提交" class="headerlink" title="1.分布式事务的提交"></a>1.分布式事务的提交</h2><p>分布式日志在本地实现为一个文件，分布式事务就是文件当中的一个记录，在系统中一次本地事务的提交对应若干个分布式事务记录的持久化，称之为分布式事务的提交。</p>
<p>在文件系统的挂载过程中，在exfs_fill_super过程中，为jbd2本地日志系统的提交注册了一个钩子函数exfs_commit_callback，用于处理单词本地事务的提交所引发的若干个分布式事务的提交的<strong>后处理</strong>（确认消息的发送）  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-分布式事务的提交&quot;&gt;&lt;a href=&quot;#1-分布式事务的提交&quot; class=&quot;headerlink&quot; title=&quot;1.分布式事务的提交&quot;&gt;&lt;/a&gt;1.分布式事务的提交&lt;/h2&gt;&lt;p&gt;分布式日志在本地实现为一个文件，分布式事务就是文件当中的一个记录，在系统中一
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>两阶段和三阶段提交协议的理解</title>
    <link href="http://yoursite.com/2018/03/15/2pcAnd3pc/"/>
    <id>http://yoursite.com/2018/03/15/2pcAnd3pc/</id>
    <published>2018-03-15T04:09:16.000Z</published>
    <updated>2018-04-08T10:26:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-2pc说明"><a href="#1-2pc说明" class="headerlink" title="1. 2pc说明"></a>1. 2pc说明</h2><p><strong>第一阶段(请求提交阶段)</strong><br>1.协调者节点向所有参与者节点询问是否可以执行提交操作，并开始等待各参与者节点的响应。<br>2.参与者节点执行询问发起为止的所有事务操作，并将undo和redo信息写进日志<br>3.各参与者节点响应协调者节点发起的询问。<br><strong>第二阶段(提交执行阶段)</strong><br>成功：<br>当协调者节点从所有参与者节点获得的相应消息都为”同意”时：<br>1.协调者节点向所有参与者节点发出”正式提交”的请求。<br>2.与者节点正式完成操作，并释放在整个事务期间内占用的资源。<br>3.参与者节点向协调者节点发送”完成”消息。<br>4.协调者节点收到所有参与者节点反馈的”完成”消息后，完成事务。<br>失败：<br>如果任一参与者节点在第一阶段返回的响应消息为”终止”，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：<br>1.协调者节点向所有参与者节点发出”回滚操作”的请求。<br>2.参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。<br>3.参与者节点向协调者节点发送”回滚完成”消息。<br>4.协调者节点收到所有参与者节点反馈的”回滚完成”消息后，取消事务。<br><strong>缺点</strong><br>很明显，容易陷入阻塞状态，占用资源得不到释放；另外，第二阶段如果协调者向参与者发出提交操作，而参与者此时崩溃，协调者无法获取参与者的响应信息。</p>
<h2 id="2-3pc说明"><a href="#2-3pc说明" class="headerlink" title="2. 3pc说明"></a>2. 3pc说明</h2><p><img src="http://ous5r4na6.bkt.clouddn.com/static/images/3pc.png" alt="">  </p>
<p>下面这段是网上看到的，解释3pc为什么相对于2pc会减少阻塞：</p>
<blockquote>
<p>在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。（其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了PreCommit请求，那么协调者产生PreCommit请求的前提条件是他在第二阶段开始之前，收到所有参与者的CanCommit响应都是Yes。（一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了）所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大） </p>
</blockquote>
<p>特殊情况：如果协调者发送了abort而某个参与者没有收到，超时之后执行commit，其他的参与者接收abort之后执行回滚，这种情况下参与者之间存在数据不一致的问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-2pc说明&quot;&gt;&lt;a href=&quot;#1-2pc说明&quot; class=&quot;headerlink&quot; title=&quot;1. 2pc说明&quot;&gt;&lt;/a&gt;1. 2pc说明&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;第一阶段(请求提交阶段)&lt;/strong&gt;&lt;br&gt;1.协调者节点向所有参与者节点
    
    </summary>
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="协议" scheme="http://yoursite.com/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>剑指1_二维数组中的查找</title>
    <link href="http://yoursite.com/2018/03/01/searinarray/"/>
    <id>http://yoursite.com/2018/03/01/searinarray/</id>
    <published>2018-03-01T11:52:56.000Z</published>
    <updated>2018-04-08T10:30:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h2 id="2-源代码"><a href="#2-源代码" class="headerlink" title="2.源代码"></a>2.源代码</h2><pre><code>class Solution {
public:
    bool Find(int target, vector&lt;vector&lt;int&gt;&gt; array) {
        bool found = false;
        int row = 0;
        int col = array[0].size() - 1;
        while (row &lt;= array.size() - 1 &amp;&amp; col &gt;= 0) {
            if (target == array[row][col]) {
                found = true;
                break;
            } 
            else if (target &lt; array[row][col])
                col--;
            else
                row++;
        }
        return found
    }
};
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h2&gt;&lt;p&gt;在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输
    
    </summary>
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>mdtest元数据测试</title>
    <link href="http://yoursite.com/2017/09/11/mdtest/"/>
    <id>http://yoursite.com/2017/09/11/mdtest/</id>
    <published>2017-09-11T13:32:34.000Z</published>
    <updated>2018-05-30T07:45:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>环境为SUSE11<br><code>CLT1:~ # zypper in openmpi openmpi-devel</code><br>报错：    </p>
<blockquote>
<p>Error building the cache:<br>[|] Repository type can’t be determined.<br>Warning: Disabling repository ‘nonoss’ because of the above error.<br>Error building the cache:<br>[|] Repository type can’t be determined.<br>Warning: Disabling repository ‘update’ because of the above error.<br>Failed to mount dvd:///?devices=/dev/sr1 on /var/adm/mount/AP_0x00000001: Mounting media failed (mount: no medium found on /dev/sr1)    </p>
</blockquote>
<p>解决：<br><img src="http://ous5r4na6.bkt.clouddn.com/static/images/mdtest.png" alt=""></p>
<p><code>CLT1:~ # zypper mr --disable 1</code>    </p>
<blockquote>
<p>Repository ‘SUSE-Linux-Enterprise-Server-11-SP1_11.1.1-1.152’ has been successfully disabled. </p>
</blockquote>
<p><code>CLT1:~ # zypper mr --disable 2</code>    </p>
<blockquote>
<p>Repository ‘SUSE-Linux-Enterprise-Software-Development-Kit-11-SP1_11.1.1-1.57’ has been successfully disabled.</p>
</blockquote>
<p><code>CLT1:~ # zypper mr --disable 4</code>    </p>
<blockquote>
<p>Repository ‘nonoss’ has been successfully disabled.</p>
</blockquote>
<p><code>CLT1:~ # zypper mr --disable 5</code>    </p>
<blockquote>
<p>Repository ‘update’ has been successfully disabled.</p>
</blockquote>
<p><strong>下载</strong><br><a href="https://jaist.dl.sourceforge.net/project/mdtest/mdtest%20latest/mdtest-1.9.3/mdtest-1.9.3.tgz" target="_blank" rel="external">mdtest</a><br>需要修改Makefile文件：    </p>
<blockquote>
<p>mdtest: mdtest.c<br>    mpicc -Wall -D $(OS) $(LARGE_FILE) $(MDTEST_FLAGS) -g -o mdtest mdtest.c -lm</p>
</blockquote>
<p><code>make mdtest</code></p>
<p><img src="http://ous5r4na6.bkt.clouddn.com/static/images/mdtest1.png" alt=""></p>
<h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h2><p>把openmpi和mdtest环境变量导出来<br><code>CLT1:~ # cat ./.bashrc</code>    </p>
<blockquote>
<p>export PATH=$PATH:/usr/lib64/mpi/gcc/openmpi/bin<br>export PATH=$PATH:/root/mdtest</p>
</blockquote>
<p>mdtest -h 看下选项，README里有几个例子。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-安装&quot;&gt;&lt;a href=&quot;#1-安装&quot; class=&quot;headerlink&quot; title=&quot;1.安装&quot;&gt;&lt;/a&gt;1.安装&lt;/h2&gt;&lt;p&gt;环境为SUSE11&lt;br&gt;&lt;code&gt;CLT1:~ # zypper in openmpi openmpi-devel&lt;/c
    
    </summary>
    
      <category term="Test" scheme="http://yoursite.com/categories/Test/"/>
    
    
      <category term="test" scheme="http://yoursite.com/tags/test/"/>
    
      <category term="metadata" scheme="http://yoursite.com/tags/metadata/"/>
    
      <category term="mdtest" scheme="http://yoursite.com/tags/mdtest/"/>
    
  </entry>
  
  <entry>
    <title>filebench测试</title>
    <link href="http://yoursite.com/2017/08/29/filebench/"/>
    <id>http://yoursite.com/2017/08/29/filebench/</id>
    <published>2017-08-29T03:38:29.000Z</published>
    <updated>2018-04-08T10:27:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-filebench下载"><a href="#1-filebench下载" class="headerlink" title="1.filebench下载"></a>1.filebench下载</h2><p>客户端安装：<a href="https://github.com/zfsonlinux/filebench" target="_blank" rel="external">filebench</a>       </p>
<p>系统:SUSE Linux Enterprise Server 11 SP1  (x86_64)       </p>
<blockquote>
<p>Filebench is a file system and storage benchmark that can generate a large<br>variety of workloads. Unlike typical benchmarks it is extremely flexible and<br>allows to specify application’s I/O behavior using its extensive Workload Model<br>Language (WML).       </p>
</blockquote>
<h2 id="2-用户自定义工作负载"><a href="#2-用户自定义工作负载" class="headerlink" title="2.用户自定义工作负载"></a>2.用户自定义工作负载</h2><p>示例：<br>一个负载包含2个进程，其中每个进程又含有三个线程。    </p>
<pre><code>01  define fileset name=&quot;testF&quot;,entries=10000,filesize=16k,prealloc,path=&quot;/tmp&quot;
02
03  define process name=&quot;readerP&quot;,instances=2 {
04    thread name=&quot;readerT&quot;,instances=3 {
05      flowop openfile name=&quot;openOP&quot;,filesetname=&quot;testF&quot;
06      flowop readwholefile name=&quot;readOP&quot;,filesetname=&quot;testF&quot;
07      flowop closefile name=&quot;closeOP&quot;
08    }
09  }
10
11  run 60
</code></pre><p>第1行定义了一个fileset, 它位于/tmp，这个set有10,000个项，每个项大小为16k。</p>
<blockquote>
<p>Filebench is instructed to<br>precreate all files in the fileset before executing the actual workload.    </p>
</blockquote>
<p>3-4行定义了两个同样的进程，每个包含三个相同的线程。    </p>
<blockquote>
<p>Every thread in Filebench repeats flowops (operations)<br>defined in it in a loop.    </p>
</blockquote>
<p>5-7行描述了flowops:    </p>
<blockquote>
<p>open a file in “testF” fileset, read the file  completely, and close<br>it.    </p>
</blockquote>
<p>最后一行指定运行这个负载的时间为60s。    </p>
<blockquote>
<p>Assuming that the personality is saved in ‘readfiles.f’ file, one can then<br>generate corresponding workload by running ‘filebench -f readfiles.f’ command.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-filebench下载&quot;&gt;&lt;a href=&quot;#1-filebench下载&quot; class=&quot;headerlink&quot; title=&quot;1.filebench下载&quot;&gt;&lt;/a&gt;1.filebench下载&lt;/h2&gt;&lt;p&gt;客户端安装：&lt;a href=&quot;https://git
    
    </summary>
    
      <category term="Test" scheme="http://yoursite.com/categories/Test/"/>
    
    
      <category term="test" scheme="http://yoursite.com/tags/test/"/>
    
      <category term="filebench" scheme="http://yoursite.com/tags/filebench/"/>
    
      <category term="metadata" scheme="http://yoursite.com/tags/metadata/"/>
    
  </entry>
  
  <entry>
    <title>CLion中的apue编译问题</title>
    <link href="http://yoursite.com/2017/08/22/apue_h/"/>
    <id>http://yoursite.com/2017/08/22/apue_h/</id>
    <published>2017-08-22T03:59:53.000Z</published>
    <updated>2018-04-08T10:26:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚开始接触CLion, 编译apue里的文件时候出了问题，还是说”apue.h”找不到，err_sys这些没有。<br>网上有的写的东西简直是误人子弟，其实很简单，之前的操作已经把apue.h放到了/usr/include/目录下，我们要做的就是：<br><img src="http://ous5r4na6.bkt.clouddn.com/static/images/apueh.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚开始接触CLion, 编译apue里的文件时候出了问题，还是说”apue.h”找不到，err_sys这些没有。&lt;br&gt;网上有的写的东西简直是误人子弟，其实很简单，之前的操作已经把apue.h放到了/usr/include/目录下，我们要做的就是：&lt;br&gt;&lt;img src=
    
    </summary>
    
      <category term="apue" scheme="http://yoursite.com/categories/apue/"/>
    
    
      <category term="apue" scheme="http://yoursite.com/tags/apue/"/>
    
      <category term="CLion" scheme="http://yoursite.com/tags/CLion/"/>
    
  </entry>
  
  <entry>
    <title>apue_hole遇到的坑</title>
    <link href="http://yoursite.com/2017/08/22/apue_hole/"/>
    <id>http://yoursite.com/2017/08/22/apue_hole/</id>
    <published>2017-08-22T03:34:54.000Z</published>
    <updated>2018-04-08T10:25:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-编译c文件出错"><a href="#1-编译c文件出错" class="headerlink" title="1.编译c文件出错"></a>1.编译c文件出错</h2><p><strong>报错如下：</strong><br><img src="http://ous5r4na6.bkt.clouddn.com/static/images/apue_hole.png" alt=""></p>
<p>看到<strong>clang error</strong></p>
<blockquote>
<p>clang是一个C、C++、Objective-C和Objective-C++编程语言的编译器前端。它采用了底层虚拟机（LLVM）作为其后端。</p>
</blockquote>
<p>然后用gcc编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc-7 -o hole file_hole.c</div></pre></td></tr></table></figure></p>
<p><strong>报错如下：</strong><br><img src="http://ous5r4na6.bkt.clouddn.com/static/images/apu_hole1.png" alt=""></p>
<p>额。。。再回去看源码发现是把creat函数写成了create…</p>
<p>改过来之后，ok<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">➜  ~ ls -l file.hole		</div><div class="line">-rw-r--r--  1 xxx  staff  16394 Aug 22 11:48 file.hole    </div><div class="line">➜  ~ od -c file.hole</div><div class="line">0000000    a   b   c   d   e   f   g   h   i   j  \0  \0  \0  \0  \0  \0</div><div class="line">0000020   \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0</div><div class="line">*</div><div class="line">0040000    A   B   C   D   E   F   G   H   I   J</div><div class="line">0040012</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-编译c文件出错&quot;&gt;&lt;a href=&quot;#1-编译c文件出错&quot; class=&quot;headerlink&quot; title=&quot;1.编译c文件出错&quot;&gt;&lt;/a&gt;1.编译c文件出错&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;报错如下：&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;http:/
    
    </summary>
    
      <category term="apue" scheme="http://yoursite.com/categories/apue/"/>
    
    
      <category term="apue" scheme="http://yoursite.com/tags/apue/"/>
    
      <category term="clang" scheme="http://yoursite.com/tags/clang/"/>
    
  </entry>
  
  <entry>
    <title>sed用法</title>
    <link href="http://yoursite.com/2017/08/13/sed/"/>
    <id>http://yoursite.com/2017/08/13/sed/</id>
    <published>2017-08-13T07:26:01.000Z</published>
    <updated>2018-04-08T10:29:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><blockquote>
<p>sed is a stream editor. A stream editor is used to perform basic text transformations on an input stream (a file or input from a pipeline). While in some ways similar to an editor which permits scripted edits (such as ed), sed works by making only one pass over the input(s), and is consequently more efficient. But it is sed’s ability to filter text in a pipeline which particularly distinguishes it from other types of editors.    </p>
</blockquote>
<h2 id="1-删除指定行"><a href="#1-删除指定行" class="headerlink" title="1. 删除指定行"></a>1. 删除指定行</h2><p><strong>实例:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">line=$(cat /etc/exports | grep -n /bwfs/fs2 | grep -v &apos;#&apos; | awk &apos;BEGIN &#123;FS=&quot;:&quot;&#125; &#123;print $1&#125;&apos;)               </div><div class="line">if [ &quot;$line&quot; != &quot;0&quot; ]; then      </div><div class="line">    sed -i &apos;/fs2/d&apos; /etc/exports    </div><div class="line">fi</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;sed&quot;&gt;&lt;a href=&quot;#sed&quot; class=&quot;headerlink&quot; title=&quot;sed&quot;&gt;&lt;/a&gt;sed&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;sed is a stream editor. A stream editor is used to pe
    
    </summary>
    
      <category term="shell" scheme="http://yoursite.com/categories/shell/"/>
    
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
      <category term="sed" scheme="http://yoursite.com/tags/sed/"/>
    
  </entry>
  
</feed>
