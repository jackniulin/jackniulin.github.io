<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lin Niu</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-22T12:46:32.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>燕云十八飞骑，奔腾如虎风烟举</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/03/22/jbd/"/>
    <id>http://yoursite.com/2018/03/22/jbd/</id>
    <published>2018-03-22T12:42:35.000Z</published>
    <updated>2018-03-22T12:46:32.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h2 id="jbd源代码分析"><a href="#jbd源代码分析" class="headerlink" title="jbd源代码分析"></a>jbd源代码分析</h2><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>1.buffer_head<br>内核用于管理磁盘缓冲区的数据结构，一个buffer_head对应一个文件系统块，即对应一个磁盘块。</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;jbd源代码分析&quot;&gt;&lt;a href=&quot;#jbd源代码分析&quot; class=&quot;headerlink&quot; title=&quot;jbd源代码分析&quot;&gt;&lt;/a&gt;jbd源代码分析&lt;/h2&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerl
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分布式事务的提交</title>
    <link href="http://yoursite.com/2018/03/19/dt/"/>
    <id>http://yoursite.com/2018/03/19/dt/</id>
    <published>2018-03-19T09:31:48.000Z</published>
    <updated>2018-03-19T09:36:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-分布式事务的提交"><a href="#1-分布式事务的提交" class="headerlink" title="1.分布式事务的提交"></a>1.分布式事务的提交</h2><p>分布式日志在本地实现为一个文件，分布式事务就是文件当中的一个记录，在系统中一次本地事务的提交对应若干个分布式事务记录的持久化，称之为分布式事务的提交。</p>
<p>在文件系统的挂载过程中，在exfs_fill_super过程中，为jbd2本地日志系统的提交注册了一个钩子函数exfs_commit_callback，用于处理单词本地事务的提交所引发的若干个分布式事务的提交的<strong>后处理</strong>（确认消息的发送）  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-分布式事务的提交&quot;&gt;&lt;a href=&quot;#1-分布式事务的提交&quot; class=&quot;headerlink&quot; title=&quot;1.分布式事务的提交&quot;&gt;&lt;/a&gt;1.分布式事务的提交&lt;/h2&gt;&lt;p&gt;分布式日志在本地实现为一个文件，分布式事务就是文件当中的一个记录，在系统中一
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>剑指1_二维数组中的查找</title>
    <link href="http://yoursite.com/2018/03/01/%E5%89%91%E6%8C%871/"/>
    <id>http://yoursite.com/2018/03/01/剑指1/</id>
    <published>2018-03-01T11:52:56.000Z</published>
    <updated>2018-03-01T12:24:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h2 id="2-源代码"><a href="#2-源代码" class="headerlink" title="2.源代码"></a>2.源代码</h2><pre><code>class Solution {
public:
    bool Find(int target, vector&lt;vector&lt;int&gt;&gt; array) {
        bool found = false;
        int row = 0;
        int col = array[0].size() - 1;
        while (row &lt;= array.size() - 1 &amp;&amp; col &gt;= 0) {
            if (target == array[row][col]) {
                found = true;
                break;
            } 
            else if (target &lt; array[row][col])
                col--;
            else
                row++;
        }
        return found
    }
};
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h2&gt;&lt;p&gt;在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mdtest元数据测试</title>
    <link href="http://yoursite.com/2017/09/11/mdtest/"/>
    <id>http://yoursite.com/2017/09/11/mdtest/</id>
    <published>2017-09-11T13:32:34.000Z</published>
    <updated>2017-09-19T01:28:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>环境为SUSE11<br><code>CLT1:~ # zypper in openmpi openmpi-devel</code><br>报错：    </p>
<blockquote>
<p>Error building the cache:<br>[|] Repository type can’t be determined.<br>Warning: Disabling repository ‘nonoss’ because of the above error.<br>Error building the cache:<br>[|] Repository type can’t be determined.<br>Warning: Disabling repository ‘update’ because of the above error.<br>Failed to mount dvd:///?devices=/dev/sr1 on /var/adm/mount/AP_0x00000001: Mounting media failed (mount: no medium found on /dev/sr1)    </p>
</blockquote>
<p>解决：<br><img src="http://ous5r4na6.bkt.clouddn.com/static/images/mdtest.png" alt=""></p>
<p><code>CLT1:~ # zypper mr --disable 1</code>    </p>
<blockquote>
<p>Repository ‘SUSE-Linux-Enterprise-Server-11-SP1_11.1.1-1.152’ has been successfully disabled. </p>
</blockquote>
<p><code>CLT1:~ # zypper mr --disable 2</code>    </p>
<blockquote>
<p>Repository ‘SUSE-Linux-Enterprise-Software-Development-Kit-11-SP1_11.1.1-1.57’ has been successfully disabled.</p>
</blockquote>
<p><code>CLT1:~ # zypper mr --disable 4</code>    </p>
<blockquote>
<p>Repository ‘nonoss’ has been successfully disabled.</p>
</blockquote>
<p><code>CLT1:~ # zypper mr --disable 5</code>    </p>
<blockquote>
<p>Repository ‘update’ has been successfully disabled.</p>
</blockquote>
<p><strong>下载</strong><br><a href="https://jaist.dl.sourceforge.net/project/mdtest/mdtest%20latest/mdtest-1.9.3/mdtest-1.9.3.tgz" target="_blank" rel="external">mdtest</a><br>需要修改Makefile文件：    </p>
<blockquote>
<p>mdtest: mdtest.c<br>    mpicc -Wall -D $(OS) $(LARGE_FILE) $(MDTEST_FLAGS) -g -o mdtest mdtest.c -lm</p>
</blockquote>
<p><code>make mdtest</code></p>
<p><img src="http://ous5r4na6.bkt.clouddn.com/static/images/mdtest1.png" alt=""></p>
<h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h2><p>把openmpi和mdtest环境变量导出来<br><code>CLT1:~ # cat ./.bashrc</code>    </p>
<blockquote>
<p>export PATH=$PATH:/usr/lib64/mpi/gcc/openmpi/bin<br>export PATH=$PATH:/root/mdtest</p>
</blockquote>
<p>mdtest -h 看下选项，README里有几个例子。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-安装&quot;&gt;&lt;a href=&quot;#1-安装&quot; class=&quot;headerlink&quot; title=&quot;1.安装&quot;&gt;&lt;/a&gt;1.安装&lt;/h2&gt;&lt;p&gt;环境为SUSE11&lt;br&gt;&lt;code&gt;CLT1:~ # zypper in openmpi openmpi-devel&lt;/c
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>filebench测试</title>
    <link href="http://yoursite.com/2017/08/29/filebench/"/>
    <id>http://yoursite.com/2017/08/29/filebench/</id>
    <published>2017-08-29T03:38:29.000Z</published>
    <updated>2017-08-29T08:32:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-filebench下载"><a href="#1-filebench下载" class="headerlink" title="1.filebench下载"></a>1.filebench下载</h2><p>客户端安装：<a href="https://github.com/zfsonlinux/filebench" target="_blank" rel="external">filebench</a>       </p>
<p>系统:SUSE Linux Enterprise Server 11 SP1  (x86_64)       </p>
<blockquote>
<p>Filebench is a file system and storage benchmark that can generate a large<br>variety of workloads. Unlike typical benchmarks it is extremely flexible and<br>allows to specify application’s I/O behavior using its extensive Workload Model<br>Language (WML).       </p>
</blockquote>
<h2 id="2-用户自定义工作负载"><a href="#2-用户自定义工作负载" class="headerlink" title="2.用户自定义工作负载"></a>2.用户自定义工作负载</h2><p>示例：<br>一个负载包含2个进程，其中每个进程又含有三个线程。    </p>
<pre><code>01  define fileset name=&quot;testF&quot;,entries=10000,filesize=16k,prealloc,path=&quot;/tmp&quot;
02
03  define process name=&quot;readerP&quot;,instances=2 {
04    thread name=&quot;readerT&quot;,instances=3 {
05      flowop openfile name=&quot;openOP&quot;,filesetname=&quot;testF&quot;
06      flowop readwholefile name=&quot;readOP&quot;,filesetname=&quot;testF&quot;
07      flowop closefile name=&quot;closeOP&quot;
08    }
09  }
10
11  run 60
</code></pre><p>第1行定义了一个fileset, 它位于/tmp，这个set有10,000个项，每个项大小为16k。</p>
<blockquote>
<p>Filebench is instructed to<br>precreate all files in the fileset before executing the actual workload.    </p>
</blockquote>
<p>3-4行定义了两个同样的进程，每个包含三个相同的线程。    </p>
<blockquote>
<p>Every thread in Filebench repeats flowops (operations)<br>defined in it in a loop.    </p>
</blockquote>
<p>5-7行描述了flowops:    </p>
<blockquote>
<p>open a file in “testF” fileset, read the file  completely, and close<br>it.    </p>
</blockquote>
<p>最后一行指定运行这个负载的时间为60s。    </p>
<blockquote>
<p>Assuming that the personality is saved in ‘readfiles.f’ file, one can then<br>generate corresponding workload by running ‘filebench -f readfiles.f’ command.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-filebench下载&quot;&gt;&lt;a href=&quot;#1-filebench下载&quot; class=&quot;headerlink&quot; title=&quot;1.filebench下载&quot;&gt;&lt;/a&gt;1.filebench下载&lt;/h2&gt;&lt;p&gt;客户端安装：&lt;a href=&quot;https://git
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CLion中的apue编译问题</title>
    <link href="http://yoursite.com/2017/08/22/apue_h/"/>
    <id>http://yoursite.com/2017/08/22/apue_h/</id>
    <published>2017-08-22T03:59:53.000Z</published>
    <updated>2017-08-22T04:09:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚开始接触CLion, 编译apue里的文件时候出了问题，还是说”apue.h”找不到，err_sys这些没有。<br>网上有的写的东西简直是误人子弟，其实很简单，之前的操作已经把apue.h放到了/usr/include/目录下，我们要做的就是：<br><img src="http://ous5r4na6.bkt.clouddn.com/static/images/apueh.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚开始接触CLion, 编译apue里的文件时候出了问题，还是说”apue.h”找不到，err_sys这些没有。&lt;br&gt;网上有的写的东西简直是误人子弟，其实很简单，之前的操作已经把apue.h放到了/usr/include/目录下，我们要做的就是：&lt;br&gt;&lt;img src=
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>apue_hole遇到的坑</title>
    <link href="http://yoursite.com/2017/08/22/apue_hole/"/>
    <id>http://yoursite.com/2017/08/22/apue_hole/</id>
    <published>2017-08-22T03:34:54.000Z</published>
    <updated>2017-08-29T08:38:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-编译c文件出错"><a href="#1-编译c文件出错" class="headerlink" title="1.编译c文件出错"></a>1.编译c文件出错</h2><p><strong>报错如下：</strong><br><img src="http://ous5r4na6.bkt.clouddn.com/static/images/apue_hole.png" alt=""></p>
<p>看到<strong>clang error</strong></p>
<blockquote>
<p>clang是一个C、C++、Objective-C和Objective-C++编程语言的编译器前端。它采用了底层虚拟机（LLVM）作为其后端。</p>
</blockquote>
<p>然后用gcc编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc-7 -o hole file_hole.c</div></pre></td></tr></table></figure></p>
<p><strong>报错如下：</strong><br><img src="http://ous5r4na6.bkt.clouddn.com/static/images/apu_hole1.png" alt=""></p>
<p>额。。。再回去看源码发现是把creat函数写成了create…</p>
<p>改过来之后，ok<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">➜  ~ ls -l file.hole		</div><div class="line">-rw-r--r--  1 xxx  staff  16394 Aug 22 11:48 file.hole    </div><div class="line">➜  ~ od -c file.hole</div><div class="line">0000000    a   b   c   d   e   f   g   h   i   j  \0  \0  \0  \0  \0  \0</div><div class="line">0000020   \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0</div><div class="line">*</div><div class="line">0040000    A   B   C   D   E   F   G   H   I   J</div><div class="line">0040012</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-编译c文件出错&quot;&gt;&lt;a href=&quot;#1-编译c文件出错&quot; class=&quot;headerlink&quot; title=&quot;1.编译c文件出错&quot;&gt;&lt;/a&gt;1.编译c文件出错&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;报错如下：&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;http:/
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>sed用法</title>
    <link href="http://yoursite.com/2017/08/13/sed/"/>
    <id>http://yoursite.com/2017/08/13/sed/</id>
    <published>2017-08-13T07:26:01.000Z</published>
    <updated>2017-08-21T04:06:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><blockquote>
<p>sed is a stream editor. A stream editor is used to perform basic text transformations on an input stream (a file or input from a pipeline). While in some ways similar to an editor which permits scripted edits (such as ed), sed works by making only one pass over the input(s), and is consequently more efficient. But it is sed’s ability to filter text in a pipeline which particularly distinguishes it from other types of editors.    </p>
</blockquote>
<h2 id="1-删除指定行"><a href="#1-删除指定行" class="headerlink" title="1. 删除指定行"></a>1. 删除指定行</h2><p><strong>实例:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">line=$(cat /etc/exports | grep -n /bwfs/fs2 | grep -v &apos;#&apos; | awk &apos;BEGIN &#123;FS=&quot;:&quot;&#125; &#123;print $1&#125;&apos;)               </div><div class="line">if [ &quot;$line&quot; != &quot;0&quot; ]; then      </div><div class="line">    sed -i &apos;/fs2/d&apos; /etc/exports    </div><div class="line">fi</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;sed&quot;&gt;&lt;a href=&quot;#sed&quot; class=&quot;headerlink&quot; title=&quot;sed&quot;&gt;&lt;/a&gt;sed&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;sed is a stream editor. A stream editor is used to pe
    
    </summary>
    
    
  </entry>
  
</feed>
